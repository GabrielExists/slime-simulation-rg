#[cfg(test)]
mod tests {
    fn lerp(from: f32, to: f32, interpolation: f32) -> f32 {
        from + (to - from) * interpolation
    }

    #[test]
    fn test_lerp() {
        assert_eq!(lerp(50.0, 120.0, 0.0), 50.0);
        assert_eq!(lerp(50.0, 120.0, 1.0), 120.0);
        assert_eq!(lerp(50.0, 120.0, 0.5), 85.0);
    }

    fn check_interpolation(total_steps: u32) -> f32 {
        let delta_time = 1.0 / total_steps as f32;
        let target = 100.0;
        let mut value = 0.0;
        for i in 0..total_steps {
            value = lerp(value, target, delta_time);
        }
        value
    }

    #[test]
    fn test_linear_step_size() {
        let pairs = (1..=20).map(|i| {
            (i, check_interpolation(i))
        }).collect::<Vec<_>>();

        let expected_pairs = vec![
            (1, 100.0),
            (2, 75.0),
            (3, 70.37037),
            (4, 68.359375),
            (5, 67.232),
            (6, 66.5102),
            (7, 66.00833),
            (8, 65.63911),
            (9, 65.35606),
            (10, 65.13216),
            (11, 64.950615),
            (12, 64.80044),
            (13, 64.67415),
            (14, 64.56647),
            (15, 64.473564),
            (16, 64.392586),
            (17, 64.32138),
            (18, 64.25827),
            (19, 64.201965),
            (20, 64.151405),
        ];
        assert_eq!(pairs, expected_pairs)
    }

    #[test]
    fn test_pow_size() {
        let pairs = (0..20).map(|i| {
            let n = 2u32.pow(i);
            (n, check_interpolation(n))
        }).collect::<Vec<_>>();

        let expected_pairs = vec![
            (1, 100.0),
            (2, 75.0),
            (4, 68.359375),
            (8, 65.63911),
            (16, 64.392586),
            (32, 63.794468),
            (64, 63.50135),
            (128, 63.356216),
            (256, 63.284027),
            (512, 63.247997),
            (1024, 63.23002),
            (2048, 63.221027),
            (4096, 63.216576),
            (8192, 63.214317),
            (16384, 63.213177),
            (32768, 63.212616),
            (65536, 63.21223),
            (131072, 63.212395),
            (262144, 63.211086),
            (524288, 63.213688),
        ];

        assert_eq!(pairs, expected_pairs)
    }

    fn lerp_f64(from: f64, to: f64, interpolation: f64) -> f64 {
        from + (to - from) * interpolation
    }

    fn check_interpolation_f64<>(total_steps: u32, overshoot: f64) -> f64 {
        let delta_time = overshoot / total_steps as f64;
        let target = 100.0;
        let mut value = 0.0;
        for i in 0..total_steps {
            value = lerp_f64(value, target, delta_time);
        }
        value
    }

    #[test]
    fn test_pow_size_f64() {
        let pairs = (0..20).map(|i| {
            let n = 2u32.pow(i);
            (n, check_interpolation_f64(n, 1.0))
        }).collect::<Vec<_>>();

        let expected_pairs = vec![
            (1, 100.0),
            (2, 75.0),
            (4, 68.359375),
            (8, 65.63910841941833),
            (16, 64.39258695482071),
            (32, 63.794471074368346),
            (64, 63.50134757560926),
            (128, 63.35622840779627),
            (256, 63.28402451084635),
            (512, 63.24801087454649),
            (1024, 63.23002605887294),
            (2048, 63.221039142248166),
            (4096, 63.216547055565485),
            (8192, 63.21430135498492),
            (16384, 63.213178590366596),
            (32768, 63.21261722947257),
            (65536, 63.212336554379824),
            (131072, 63.21219621817242),
            (262144, 63.21212605040276),
            (524288, 63.21209096660147),
        ];

        assert_eq!(pairs, expected_pairs)
    }

    #[test]
    fn test_pow_size_overshoot_f64() {
        let pairs = (0..20).map(|i| {
            let n = 2u32.pow(i);
            (n, check_interpolation_f64(n, 2.0))
        }).collect::<Vec<_>>();

        let expected_pairs = vec![
            (1, 200.0),
            (2, 100.0),
            (4, 93.75),
            (8, 89.98870849609375),
            (16, 88.19329129787512),
            (32, 87.32112136229996),
            (64, 86.89159675215248),
            (128, 86.67848371203517),
            (256, 86.57234003498405),
            (512, 86.51937143879866),
            (1024, 86.49291295322546),
            (2048, 86.4796901636883),
            (4096, 86.47308038223974),
            (8192, 86.46977589484561),
            (16384, 86.46812375198091),
            (32768, 86.46729770575686),
            (65536, 86.46688468894673),
            (131072, 86.46667818211793),
            (262144, 86.46657492909713),
            (524288, 86.46652330268566),
        ];

        assert_eq!(pairs, expected_pairs)
    }

    #[test]
    fn test_overshoot() {
        let pairs = (1..=20).map(|i| {
            let overshoot = 1.0 + (i as f64 / 10.0);
            let n = 32768;
            (overshoot, check_interpolation_f64(n, overshoot))
        }).collect::<Vec<_>>();

        let expected_pairs = vec![
            (1.1, 66.71350622264065),
            (1.2, 69.88124062135418),
            (1.3, 72.74752349349421),
            (1.4, 75.34104111894435),
            (1.5, 77.68775005199622),
            (1.6, 79.81113686907702),
            (1.7, 81.73245320081128),
            (1.8, 83.47092840008888),
            (1.9, 85.04396197409208),
            (2.0, 86.46729770575686),
            (2.1, 87.75518120691508),
            (2.2, 88.92050247963437),
            (2.3, 89.97492491222836),
            (2.4, 90.9290020007132),
            (2.5, 91.79228296364788),
            (2.6, 92.57340830718692),
            (2.7, 93.2801962965988),
            (2.8, 93.91972119953417),
            (2.9, 94.49838408397649),
            (3.0, 95.02197687933347)];

        assert_eq!(pairs, expected_pairs)
    }

    #[test]
    fn test_overshoot_halves() {
        let pairs = (1..=20).map(|i| {
            let overshoot = 1.0 + (i as f64 / 2.0);
            let n = 32768;
            (overshoot, check_interpolation_f64(n, overshoot))
        }).collect::<Vec<_>>();

        let expected_pairs = vec![
            (1.5, 77.68775005199622),
            (2.0, 86.46729770575686),
            (2.5, 91.79228296364788),
            (3.0, 95.02197687933347),
            (3.5, 96.98082609519955),
            (4.0, 98.16888325208313),
            (4.5, 98.88944358198493),
            (5.0, 99.32646230949226),
            (5.5, 99.5915114702555),
            (6.0, 99.75226092348053),
            (6.5, 99.84975298657169),
            (7.0, 99.90887996731801),
            (7.5, 99.94473902146943),
            (8.0, 99.96648648656901),
            (8.5, 99.97967558593406),
            (9.0, 99.98767426594118),
            (9.5, 99.99252511979519),
            (10.0, 99.99546693062858),
            (10.5, 99.99725098456479),
            (11.0, 99.99833291142235)];


        assert_eq!(pairs, expected_pairs)
    }
}
